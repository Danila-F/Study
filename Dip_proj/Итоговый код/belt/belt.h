/*
*******************************************************************************
Шифрование в режиме счетчика
*******************************************************************************
*/

#define B_PER_W 16
#define O_PER_W (B_PER_W / 8)
typedef unsigned short WORD;
typedef unsigned long u32;
typedef signed long i32;
typedef unsigned char u8;
typedef signed char i8;
typedef u8 octet;
typedef unsigned int size_t;

typedef struct
{
	u32 key[8];			//форматированный ключ
	u32 ctr[4];			//счетчик
	octet block[16];	//блок гаммы
	size_t reserved;	//резерв октетов гаммы
} belt_ctr_st;

/*
*******************************************************************************
Ускорители

Реализованы быстрые операции над блоками и полублоками belt. Блок
представляется либо как [16]octet, либо как [4]u32,
либо как [W_OF_B(128)]word.

Суффикс U32 в именах макросов и функций означает, что данные интерпретируются
как массив u32. Суффикс W означает, что данные интерпретируются как
массив word.
*******************************************************************************
*/

#define beltBlockIncU32(block)\
	if ((((u32*)(block))[0] += 1) == 0 &&\
		(((u32*)(block))[1] += 1) == 0 &&\
		(((u32*)(block))[2] += 1) == 0)\
		((u32*)(block))[3] += 1\

#define beltBlockCopy(dest, src)\
	((WORD*)(dest))[0] = ((const WORD*)(src))[0],\
	((WORD*)(dest))[1] = ((const WORD*)(src))[1],\
	((WORD*)(dest))[2] = ((const WORD*)(src))[2],\
	((WORD*)(dest))[3] = ((const WORD*)(src))[3]\

#define beltBlockXor2(dest, src)\
	((WORD*)(dest))[0] ^= ((const WORD*)(src))[0],\
	((WORD*)(dest))[1] ^= ((const WORD*)(src))[1],\
	((WORD*)(dest))[2] ^= ((const WORD*)(src))[2],\
	((WORD*)(dest))[3] ^= ((const WORD*)(src))[3]\

/*!
*******************************************************************************
Блоб -- объект в памяти определенного размера. В функциях работы с блобами
используются их дескрипторы -- "умные" указатели. С дескрипторами можно
работать как с обычными указателями, т.е. использовать их в функциях типа
memcpy, memset. Дополнительно по указателю можно определить размер блоба.

Реализация работы с блобами может быть платформенно-зависимой.

Реализация должна гарантировать защиту содержимого блобов от утечек,
например, через файл подкачки. Поэтому в блобах рекомендуется размещать
ключи и другие критические объекты.

В функциях работы с блобами дескрипторы входных блобов корректны.
*******************************************************************************
*/

// память для блобов выделяется страницами
#define BLOB_PAGE_SIZE 1024

// требуется страниц
#define blobPageCount(size)\
	(((size) + sizeof(size_t) + BLOB_PAGE_SIZE - 1) / BLOB_PAGE_SIZE)

// требуется памяти на страницах
#define blobActualSize(size)\
	(blobPageCount(size) * BLOB_PAGE_SIZE)

// heap-указатель для блоба
#define blobPtrOf(blob) ((size_t*)blob - 1)

// размер блоба
#define blobSizeOf(blob) (*blobPtrOf(blob))

// страничный размер блоба
#define blobActualSizeOf(blob) (blobActualSize(blobSizeOf(blob)))

// блоб для heap-указателя
#define blobValueOf(ptr) ((blob_t)((size_t*)ptr + 1))

// дескриптор блоба
typedef void* blob_t;

/*	Инициализация шифрования в режиме CTR

	По ключу [len]key и синхропосылке iv в state формируются
	структуры данных, необходимые для шифрования в режиме CTR.
	len == 16 || len == 24 || len == 32.
	По адресу state зарезервировано beltCTR_keep() октетов.
	Буферы key и state могут пересекаться.
*/
void beltCTRStart(
	void* state,			//[out] состояние
	const octet key[],		//[in] ключ
	size_t len,				//[in] длина ключа в октетах
	const octet iv[16]		//[in] синхропосылка
);

/*	Зашифрование фрагмента в режиме CTR

	Буфер [count]buf зашифровывается в режиме CTR на ключе, размещенном
	в state.
	beltCTRStart() < beltCTRStepE()*.
*/
void beltCTRStepE(
	void* buf,			//[in/out] открытый текст / шифртекст
	size_t count,		//[in] число октетов текста
	void* state			//[in/out] состояние
);

/*	Расшифрование фрагмента в режиме CTR
	Зашифрование в режиме CTR не отличается от расшифрования.
*/
#define beltCTRStepD beltCTRStepE

/*	Шифрование в режиме CTR

	Буфер [count]src зашифровывается или расшифровывается на ключе
	[len]key с использованием синхропосылки iv. Результат шифрования
	размещается в буфере [count]dest.
	{ERR_BAD_INPUT} len == 16 || len == 24 || len == 32.
	ERR_OK, если шифрование завершено успешно, и код ошибки
	в противном случае.
	Буферы могут пересекаться.
*/
