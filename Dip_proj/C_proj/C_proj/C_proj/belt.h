/*
*******************************************************************************
Шифрование в режиме счетчика (belt-ctr, CTR)
*******************************************************************************
*/

typedef unsigned long u32;
typedef signed long i32;
typedef unsigned char u8;
typedef signed char i8;
typedef u8 octet;
typedef unsigned int size_t;

typedef struct
{
	u32 key[8];			/*< форматированный ключ */
	u32 ctr[4];			/*< счетчик */
	octet block[16];	/*< блок гаммы */
	size_t reserved;	/*< резерв октетов гаммы */
} belt_ctr_st;

/*
*******************************************************************************
Булевы данные
*******************************************************************************
*/

/*!	\brief Булев тип */
typedef int bool_t;

#ifndef TRUE
#define TRUE ((bool_t)1)
#endif

#ifndef FALSE
#define FALSE ((bool_t)0)
#endif

/*
*******************************************************************************
Ошибки
*******************************************************************************
*/

/*!	\brief Коды ошибок
	\remark Высокоуровневые функции возвращают значения типа err_t.
	Возврат ERR_OK означает, что функция завершена успешно. Код ERR_MAX
	зарезервирован для описания специальных особых ситуаций.
	Возврат других значений означает ошибку при выполнении функции.
*/
typedef u32 err_t;

/*!	\brief Код успешного завершения */
#define ERR_OK	((err_t)0)

/*!	\brief Максимальный код ошибки */
#define ERR_MAX	(ERR_OK - (err_t)1)

/*
*******************************************************************************
Sys
*******************************************************************************
*/

#define _ERR_REG(err) ((err_t)(err))

/* нераспознанная системная ошибка */
#define ERR_SYS						_ERR_REG(101)
/* некорректное устройство */
#define ERR_BAD_UNIT				_ERR_REG(102)
/* некорректный файл */
#define ERR_BAD_FILE				_ERR_REG(103)
/* некорректная функция */
#define ERR_BAD_FUNCTION			_ERR_REG(104)
/* некорректная команда */
#define ERR_BAD_COMMAND				_ERR_REG(105)
/* некорректная длина */
#define ERR_BAD_LENGTH				_ERR_REG(106)
/* некорректные входные данные */
#define ERR_BAD_INPUT				_ERR_REG(107)
/* не хватает памяти */
#define ERR_OUTOFMEMORY				_ERR_REG(108)
/* доступ запрещен */
#define ERR_ACCESS_DENIED			_ERR_REG(109)
/* устройство не готово */
#define ERR_NOT_READY				_ERR_REG(110)
/* запрашиваемый ресурс занят */
#define ERR_BUSY					_ERR_REG(111)
/* таймаут */
#define ERR_TIMEOUT					_ERR_REG(112)
/* не реализовано */
#define ERR_NOT_IMPLEMENTED			_ERR_REG(113)
/* не реализовано */
#define ERR_AFTER					_ERR_REG(114)

#define B_PER_W 32
#define O_PER_W (B_PER_W / 8)
typedef u32 word;

/*
*******************************************************************************
Замечание по интерфейсам

Состояния некоторых связок (например, beltHash) содержат память, которую
не обязательно поддерживать постоянной между обращениями к функциям связки.
Это -- дополнительный управляемый стек. Можно передавать указатель на эту
память через дополнительный параметр (stack, а не state), описав предварительно
глубину стека с помощью функций типа _deep. Мы не стали так делать, чтобы
не усложнять излишне интерфейсы.
*******************************************************************************
*/

/*
*******************************************************************************
Ускорители

Реализованы быстрые операции над блоками и полублоками belt. Блок
представляется либо как [16]octet, либо как [4]u32,
либо как [W_OF_B(128)]word.

Суффикс U32 в именах макросов и функций означает, что данные интерпретируются
как массив u32. Суффикс W означает, что данные интерпретируются как
массив word.
*******************************************************************************
*/

#define beltBlockIncU32(block)\
	if ((((u32*)(block))[0] += 1) == 0 &&\
		(((u32*)(block))[1] += 1) == 0 &&\
		(((u32*)(block))[2] += 1) == 0)\
		((u32*)(block))[3] += 1\

#define beltBlockCopy(dest, src)\
	((word*)(dest))[0] = ((const word*)(src))[0],\
	((word*)(dest))[1] = ((const word*)(src))[1],\
	((word*)(dest))[2] = ((const word*)(src))[2],\
	((word*)(dest))[3] = ((const word*)(src))[3]\

#define beltBlockXor2(dest, src)\
	((word*)(dest))[0] ^= ((const word*)(src))[0],\
	((word*)(dest))[1] ^= ((const word*)(src))[1],\
	((word*)(dest))[2] ^= ((const word*)(src))[2],\
	((word*)(dest))[3] ^= ((const word*)(src))[3]\

/*!
*******************************************************************************
\file blob.h

Блоб -- объект в памяти определенного размера. В функциях работы с блобами
используются их дескрипторы -- "умные" указатели. С дескрипторами можно
работать как с обычными указателями, т.е. использовать их в функциях типа
memcpy, memset. Дополнительно по указателю можно определить размер блоба.

Реализация работы с блобами может быть платформенно-зависимой.

Реализация должна гарантировать защиту содержимого блобов от утечек,
например, через файл подкачки. Поэтому в блобах рекомендуется размещать
ключи и другие критические объекты.

\pre В функциях работы с блобами дескрипторы входных блобов корректны.
*******************************************************************************
*/

/*! Дескриптор блоба. */
typedef void* blob_t;

/*!	\brief Создание блоба

	Создается блоб размера size.
	\return Дескриптор созданного блоба. Нулевой дескриптор возвращается
	при нулевом size и при нехватке памяти.
	\post Выходной блоб корректен.
	\remark При создании блоба все его октеты обнуляются.
*/
blob_t blobCreate(
	size_t size		/*!< [in] размер */
);

/*!	\brief Очистка и освобождение блоба

	Выполняется очистка и освобождение блоба blob.
*/
void blobClose(
	blob_t blob		/*!< [in] блоб */
);

/*!	\brief Длина состояния функций CTR

	Возвращается длина состояния (в октетах) функций шифрования в режиме CTR.
	\return Длина состояния.
*/
size_t beltCTR_keep();

/*!	\brief Инициализация шифрования в режиме CTR

	По ключу [len]key и синхропосылке iv в state формируются
	структуры данных, необходимые для шифрования в режиме CTR.
	\pre len == 16 || len == 24 || len == 32.
	\pre По адресу state зарезервировано beltCTR_keep() октетов.
	\remark Буферы key и state могут пересекаться.
*/
void beltCTRStart(
	void* state,			/*!< [out] состояние */
	const octet key[],		/*!< [in] ключ */
	size_t len,				/*!< [in] длина ключа в октетах */
	const octet iv[16]		/*!< [in] синхропосылка */
);

/*!	\brief Зашифрование фрагмента в режиме CTR

	Буфер [count]buf зашифровывается в режиме CTR на ключе, размещенном
	в state.
	\expect beltCTRStart() < beltCTRStepE()*.
*/
void beltCTRStepE(
	void* buf,			/*!< [in/out] открытый текст / шифртекст */
	size_t count,		/*!< [in] число октетов текста */
	void* state			/*!< [in/out] состояние */
);

/*!	\brief Расшифрование фрагмента в режиме CTR
	\remark Зашифрование в режиме CTR не отличается от расшифрования.
*/
#define beltCTRStepD beltCTRStepE

/*!	\brief Шифрование в режиме CTR

	Буфер [count]src зашифровывается или расшифровывается на ключе
	[len]key с использованием синхропосылки iv. Результат шифрования
	размещается в буфере [count]dest.
	\expect{ERR_BAD_INPUT} len == 16 || len == 24 || len == 32.
	\return ERR_OK, если шифрование завершено успешно, и код ошибки
	в противном случае.
	\remark Буферы могут пересекаться.
*/
err_t beltCTR(
	void* dest,				/*!< [out] шифртекст / открытый текст */
	const void* src,		/*!< [in] открытый текст / шифртекст */
	size_t count,			/*!< [in] число октетов текста */
	const octet key[],		/*!< [in] ключ */
	size_t len,				/*!< [in] длина ключа */
	const octet iv[16]		/*!< [in] синхропосылка */
);

err_t beltCTRB(
	octet* dest,			/*!< [out] шифртекст / открытый текст */
	const octet* src,		/*!< [in] открытый текст / шифртекст */
	const octet key[],		/*!< [in] ключ */
	size_t len,				/*!< [in] длина ключа */
	const octet iv[16],		/*!< [in] синхропосылка */
	blob_t* state			/*!< [in] состояние шифратора */
);
