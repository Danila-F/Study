<!-- (C) 2010 Nesterenkov Sergey, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="../../../Оболочка/css/style2.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Теория по дисциплине &quot;Программирование проблемно-ориентированных вычислительных средств реального времени&quot;</title>
<base target="_top">

<base target="_self">
<style type="text/css">
body,td,th { font-family: Times New Roman, Times, serif; }
p {margin-left: 5%; margin-right: 5%; }
</style></HEAD>

</HEAD><BODY>
<div class="Header_Style">
<table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../../Оболочка/images/background.jpg">
  <tr> 
    <td width="13%" rowspan=3 align="center" ><img src="../../../Оболочка/images/logo_new.jpg" width=117 align="middle"></td>
  <tr> 
    <td width="70%" colspan=2 align="center" valign="middle"> <H1 align="center" >&nbsp;</H1>
      <H1 align="center" >Электронный ресурс по учебной дисциплине<BR>
        "Программирование проблемно-ориентированных вычислительных средств реального времени"<BR> 
        для специальности: </H1>
<p>1-40 02 02 "Электронные вычислительные средства"
</p></td>
    <td width="12%" rowspan=3 align="center" ><img src="../../images/theory.jpg" width="146" height="85"></td>
  <Tr>
    <td align=center colspan=2><var class="Header_Style"><A HREF="../../../index.htm">Оглавление</A> | <A HREF="../../../Программа/ППОВСРВ_программа_2017.htm" >Программа</A> | <a href="../../../Теория/theory.htm">Теория</a> | <a href="../../../Практика/practice.htm">Практика</a> | <A HREF="../../../Контроль_знаний/test.htm">Контроль знаний</A> | <A HREF="../../../Об авторах/author.htm">Об авторах</A></var></var> </td>
  <tr>
</table></div>



<!--start-->
	<div class="mainTitle" align="center">
	  <h1>Лекция № 1.3</h1>
</div>
	<div>
	  <h3 align="center"><strong>Раздел 1.  Технологии и инструментальные системы программирования проблемно-ориентированных  вычислительных средств реального времени</strong></h3>
      <p><strong>1.2&nbsp;&nbsp;&nbsp; Технология создания программ на ассемблере (4  часа)</strong><br>
        <strong><em>Лекция № 1.3</em></strong><br>
        Использование алгебраического  представления ассемблерного кода.<br>
Использование макросредств языка  ассемблера. Директивы макроассемблера. <br>
Использование стандартных библиотек.<br>
      </p>
</div>


<div align="center">
	<p>
	<input type="button" class="buttonManage" value="&nbsp;Назад&nbsp;" onClick="document.location.href ='../LK02/lk_02.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Перечень тем лекций&nbsp;" onClick="document.location.href ='../../theory.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Вперед&nbsp;" onClick="document.location.href ='../LK04/lk_04.htm'" />
    </p>
</div>

<!-- (C) 2017 Shemarov Alexander, BSUIR begin-->  

<div class="Text_Style"><h1>Использование мнемонического и алгебраического представления ассемблерного кода</h1>
</div>
<div class="Text_Style">
  <p>Очень часто у студентов возникает вопрос: "Зачем нужен язык Ассемблер?"</p>
  <p>Попробуем ответить на него словами Пирогова Владислава Юрбевича, одного из ведущих специалистов в этой области, чьи книги переводятся и издаются в ведущих компьютерных изданиях мира.</p>
<p><em>&quot;Зачем  нужен язык ассемблера? - спросят меня. Самый простой и убедительный ответ на  поставленный вопрос такой - затем, что это язык процессора и, следовательно, он  будет нужен до тех пор, пока будут существовать процессоры. Более пространный  ответ на данный вопрос содержал бы в себе рассуждение о том, что ассемблер  может понадобиться для оптимизации кода программ, написания драйверов,  трансляторов, программирования некоторых внешних устройств и т.д. Для себя я,  однако, имею и другой ответ: программирование на ассемблере дает ощущение  власти над компьютером, а жажда власти - один из сильнейших инстинктов  человека.&quot;</em><br>
  <em>Ассемблер.  Учебный курс. Пирогов В.Ю.</em></p>
<p><em>&quot;Важнейшим  плюсом языка ассемблера является его близость к архитектуре компьютера и  операционной системы. Работа с языком ассемблера неизбежно приводит  программиста к очень детальному изучению функционирования компьютера и  операционной системы. Эта важная методическая особенность языка ассемблер  позволяет использовать его в качестве очень эффективного средства обучения. С  этой точки зрения обучение программированию должно обязательно включать также и  определенное количество часов, посвященных ассемблеру.&quot;</em><br>
  <em>Ассемблер  - 64. Пирогов В.Ю.</em></p>
<p><em>ПОСЛАНИЕ СТАРЫХ  МАСТЕРОВ</em></p>
<p><em>Давным-давно, в  мире, которого уже нет, старые мастера вели битву за умы и рынки своего времени  оружием, которое выражало силу и ясность, столь необходимые первооткрывателю  новых идей и умных вещей. Эти древние воины прошли огромный путь, преодолев  толщу времени и великие разногласия, чтобы принести мастерство, которым они  владели в старые времена новому молодому поколению, для того чтобы новые воины  могли нести традицию оригинальности и безкомпромисности, которая так  необходима, чтобы создавать программное обеспечение превосходного качества. </em></p>
<p><em>MASM</em><em>32 несет на себе  следы многих древних и не очень древних воинов, которые работали с ним, и если  панцирь уже кое-где проржавел, но клинок еще остер и глаз точен, и это вселяет  уверенность, что мощь прошлых времен передана поколению, которое будет делать  великие вещи и писать программы еще лучше, потому что сила молодости и точность  старых мастеров стоит за ним. Когда вы скачаете и установите </em><em>MASM</em><em>32 на свой компьютер, древние воины будут смотреть  из-за вашего плеча взглядом острым как сталь, и это не даст вам пропустить  суть, которая часто скрывается за современными причудами и модой. Не огорчите  старых воинов, чтобы они не почувствовали разочарование, если вы провалите то  дело, которое принесено из их жизней и времен. Проходя через пространство и  время, древние витязи использовали эти инструменты, которые теперь у вас. Не  успокаивайтесь только на том, чтобы использовать или копировать то, что вы  получили. Превзойдите то, что уже сделано, творите новые и оригинальные идеи,  изучайте трудные детали операционных систем и машинные инструкции и создавайте  программное обеспечение, как произведение искусства, а не как детскую игрушку  или хитроумное изобретение. </em></p>
<p><em>Древние старцы  бродят по коридорам Интернета и они не пропустят работу искусного мастера, но  они также увидят, если их последователь ошибется в их задаче и вы узнаете их  огорчение, если ваша работа не будет соответствовать тем стандартам, которые  они ожидали. Будьте безкомпромисны в поиске прекрасного, какими были старые  мастера, знайте, что легкий и удобный путь ведет к забвению, и что только  преданность делу, тяжелый труд и ясное понимание помогут вам овладеть трудным искусством,  которое даст вам великий опыт старины, взращенный древними. Уважение старинных  воинов не просто заслужить, но если вы овладеете древними искусствами и  создадите программное обеспечение, несущее печать великого мастерства вы  заслужите уважение и станете одними из них. </em></p>
<p align="right"><em>Мой вольный  перевод текста из пакета </em><em>MASM</em><em>32. . </em><em>Пирогов В.Ю.  (c), 2006</em></p>
<p>ASSEMBLER &mdash; язык программирования низкого уровня, представляющий собой  формат записи машинных команд, удобный для восприятия человеком.<br>
  Команды языка ассемблера один в один соответствуют командам процессора и,  фактически, представляют собой удобную символьную форму записи (мнемокод)  команд и их аргументов. Также язык ассемблера обеспечивает базовые программные  абстракции: связывание частей программы и данных через метки с символьными  именами и директивы.<br>
  Директивы ассемблера позволяют включать в программу блоки данных (описанные  явно или считанные из файла); повторить определённый фрагмент указанное число  раз; компилировать фрагмент по условию; задавать адрес исполнения фрагмента,  менять значения меток в процессе компиляции; использовать макроопределения с  параметрами и др.<br>
  Каждая модель процессора, в принципе, имеет свой набор команд и  соответствующий ему язык (или диалект) ассемблера.</p>
<p><br>
  ДОСТОИНСТВА И  НЕДОСТАТКИ</p>
<ul type="disc">
  <ul>
    <ul>
      <li>минимальное количество избыточного кода       (использование меньшего количества команд и обращений в память). Как       следствие &mdash; большая скорость и меньший размер программы</li>
      <li>большие объемы кода, большое число дополнительных       мелких задач</li>
      <li>плохая читабельность кода, трудность поддержки       (отладка, добавление возможностей)</li>
      <li>трудность реализации парадигм программирования и       любых других сколько-нибудь сложных конвенций, сложность совместной       разработки</li>
      <li>меньшее количество доступных библиотек, их малая       совместимость</li>
      <li>непосредственный доступ к аппаратуре: портам       ввода-вывода, особым регистрам процессора</li>
      <li>возможность написания самомодифицирующегося кода       (т.е. метапрограммирования, причем без необходимости программного       интерпретатора)</li>
      <li>максимальная &laquo;подгонка&raquo; для нужной платформы       (использование специальных инструкций, технических особенностей &laquo;железа&raquo;)</li>
      <li>непереносимость на другие платформы (кроме       двоично совместимых).</li>
    </ul>
    </ul>
  </ul>
<p align="right">&nbsp;</p>
</div>

	<div class="Text_Style">
	<p>Общепринято программы на ассемблере записывать в мнемонической форме, как это показано на примере программы, реализующей алгоритм генерирования синусоидального сигнала, подробно рассматриваемый в лекции 2.7. Стандарта мнемонического представления ассемблерных команд не существует, поэтому каждая фирма разрабатывает свой вариант представления языка ассемблера. Фирма Ttxas Instruments использует для процессоров TMS320C54XX мнемонический вариант ассемблера, представленный в следующих документах:</p>
	<p><a href="../../../Файлы/spru102e.pdf" title="Ассемблер для TMS320C54XX" target="_blank"><strong>1. TMS320C54x </strong><br>
    <strong>Assembly Language Tools </strong><br>
      <strong>User&rsquo;s Guide </strong><br>
Literature Number: SPRU102E June 2001</a></p>
	<p><a href="../../../Файлы/spru172c.pdf" title="Ассемблер для TMS320C54XX" target="_blank"><strong>2. TMS320C54x </strong><br>
      <strong>Volume 2: Mnemonic Instruction Set </strong><br>
      <strong>User&rsquo;s Guide </strong><br>
Literature Number: SPRU172C June 2001</a></p>
<blockquote>
    <blockquote>
	    <p> .mmregs<br>
	      .def	_c_int00	; Определяем переменную, определяющую стартовый адрес<br>
	      .text				; Начинаем сегмент кода<br>
	      _c_int00: </p>
	    <p> ;		инициализация<br>
	      ld		#faza, DP<br>
	      rsbx	sxm<br>
	      rsbx	frct<br>
	      ; адрес коэффициента для интерполяции <br>
	      stm		#faza+1, AR3 <br>
	      ; абсолютная разность между значениями i+1 и i<br>
	      stm		#delta, AR4</p>
	    <p> stm		#sine_bufer, AR5<br>
	      stm		#4096-1, BRC</p>
	    <p> rptb	end_block<br>
      </p>
	    <p> ;	вычисление синуса<br>
	      <br>
	      dld		faza, A<br>
	      ;		stlm	A, T<br>
	      and		#0x0FFF, 16, A<br>
	      add		#sine_table, 16, A<br>
	      sftl	A, -16, A<br>
	      stlm	A, AR2<br>
	      nop<br>
	      nop<br>
  <br>
	      ld		*AR2+, 16, B<br>
	      ld		*AR2, 16, A<br>
	      sub		B, A<br>
	      sth		A, *AR4<br>
	      sfta	B, 1, B<br>
	      macsu	*AR3, *AR4, B<br>
	      sfta	B, -1, B<br>
	      ;	значение синуса 32 разряда в акуммуляторе B</p>
	    <p> ;	вычисление следующее значение фазы<br>
	      dld		faza, A<br>
	      dadd	freq, A<br>
	      dst		A, faza <br>
	      end_block<br>
	      sth		B, *AR5+</p>
	    <p> nop<br>
      </p>
	    <p> .data<br>
	      faza	.long		4096*3*65536/360<br>
	      freq	.long		3*65536+30000 <br>
	      delta	.word		0</p>
	    <p>sine_table <br>
	      .include	&quot;sine_table1.asm&quot;<br>
	      sine_bufer<br>
	      .space		4096*16 <br>
  <br>
	      .end</p>
	    <pre>&nbsp;</pre>
    </blockquote>
	  </blockquote>
</div>

<div class="Text_Style"> <p>Результат формирования синусоидального сигнала гармоники 3.48 представлен на рисунке 1.2.5. (половина выборки - 2048 отсчетов из 4096)</p></div>

<div>
<h3 align="center"><a name="Рис1.2.5"></a><img src="../../images/Ris03_1.jpg" width="90%"></h3>
<h3 align="center">Рисунок 1.2.5 &ndash; Синусоидальный сигнал гармоники 3.48 для примера мнемонического представления языка ассемблера </h3>
</div> 

<div class="Text_Style">
	<p>Однако, многие программисты, пишущие программы на структурно-ориентированных и объектно-ориентированных языках, испытывают затруднения при написании программ на ассемблере  в мнемонической форме. Для упрощения написания программ на ассемблере фирма Ttxas Instruments предложила использовать для процессоров TMS320C54XX алгебраический вариант ассемблера, представленный в следующих документах:</p>
	<p><a href="../../../Файлы/spru102e.pdf" title="Ассемблер для TMS320C54XX" target="_blank"><strong>1. TMS320C54x </strong><br>
      <strong>Assembly Language Tools </strong><br>
      <strong>User&rsquo;s Guide </strong><br>
Literature Number: SPRU102E June 2001</a></p>
	<p><a href="../../../Файлы/spru179c.pdf" title="Ассемблер для TMS320C54XX" target="_blank"><strong>2. TMS320C54x </strong><br>
      <strong>Volume 3: Algebraic Instruction Set </strong><br>
      <strong>User&rsquo;s Guide </strong><br>
Literature Number: SPRU179C March 2001</a></p>
<p>Программирование с использованием алгебраической формы представления команд ассемблера показано на примере программы, реализующей алгоритм генерирования синусоидального сигнала, подробно рассматриваемый в лекции 2.7. </p>
<blockquote>
    <blockquote>
	    <p> .mmregs<br>
.def	_c_int00	; Определяем переменную, определяющую стартовый адрес<br>
.text				; Начинаем сегмент кода<br>
.algebraic<br>
_c_int00: </p>
	    <p> ;		инициализация<br>
	      DP = #faza<br>
	      SXM = 0<br>
	      FRCT = 0<br>
	      ; адрес коэффициента для интерполяции </p>
	    <p> AR3 = #(faza+1) <br>
	      ; абсолютная разность между значениями i+1 и i<br>
	      AR4 = #delta</p>
	    <p> AR5	= #sine_bufer<br>
	      BRC = #(4096-1) </p>
	    <p> blockrepeat	(end_block)<br>
      </p>
	    <p> ;	вычисление синуса<br>
	      <br>
	      A = dbl(faza)</p>
	    <p> A &amp;= #0x0FFF &lt;&lt; 16<br>
	      A += #sine_table &lt;&lt; 16<br>
	      A = A &lt;&lt;C -16<br>
	      AR2	= A<br>
	      nop<br>
	      nop<br>
  <br>
	      B =	*AR2+ &lt;&lt; 16<br>
	      A = *AR2 &lt;&lt; 16<br>
	      A -= B<br>
	      *AR4 = hi(A)<br>
	      B =	B &lt;&lt;C 1<br>
	      ;		macsu	*AR3, *AR4, B<br>
	      B += uns(*AR3)*(*AR4)<br>
	      B =	B &lt;&lt;C -1<br>
	      ;	значение синуса 32 разряда в акуммуляторе B</p>
	    <p> ;	вычисление следующее значение фазы<br>
	      A = dbl(faza)<br>
	      A += dbl(freq)<br>
	      dbl(faza) =	A <br>
	      end_block<br>
	      *AR5+ = hi(B)</p>
	    <p> nop<br>
      </p>
	    <p> .data<br>
	      faza	.long		4096*121*65536/360<br>
	      freq	.long		7*65536+16384 <br>
	      delta	.word		0</p>
	    <p>sine_table <br>
	      .include	&quot;sine_table1.asm&quot;<br>
	      sine_bufer<br>
	      .space		4096*16 <br>
  <br>
	      .end</p>
<pre>&nbsp;</pre>
    </blockquote>
  </blockquote>
</div>

<div class="Text_Style"> <p>Результат формирования синусоидального сигнала гармоники 7.25 представлен на рисунке 1.2.6. (половина выборки - 2048 отсчетов из 4096)</p></div>

<div>
<h3 align="center"><a name="Рис1.2.6"></a><img src="../../images/Ris03_2.jpg" width="90%"></h3>
<h3 align="center">Рисунок 1.2.6 &ndash; Синусоидальный сигнал гармоники 7.25 для примера алгебраического представления языка ассемблера </h3>
</div> 
<div class="Text_Style">
  <h1>Использование макросредств языка  ассемблера и директивы макроассемблера</h1>
</div>
<div class="Text_Style"><p>При  всех возможностях создания эффективного кода программирование на ассемблере  представляет собой весьма трудоемкую задачу, что часто отпугивает разработчиков,  не обладающих достаточными компетенциями в этой области. Для создания  эффективного кода в языке ассемблера существуют возможность использования  макросредств, позволяющих автоматически генерировать код по ранее  подготовленному шаблону. Использование макроассемблера делает процесс  программирования весьма эффективным. <br>
Генерирование  кода с помощью макросредств - процесс создание ассемблерного кода по ранее  написанному шаблону, который представляет собой достаточно сложную программу,  использующую формальные параметры: ключевые или перечисляемые, называется  процессом создания <em>макрорасширения</em>.  Шаблон, по которому генерируется ассемблерный код, в свою очередь называется <em>макроопределением</em>. Процесс инициируется <em>макрокомандой</em>, вызывающей нужное  макроопределение и передающей в него фактические параметры, количество и вид  которых напрямую может управлять процессом макрогенерации. <br>
Процесс  макрогенерирования кода представлен на рисунке 1.2.7.</p>
</div>
<div>
<h3 align="center"><a name="Рис1.2.7"><img src="../../images/ris010207.gif" width="700"></a></h3>
<h3 align="center">Рисунок 1.2.7 &ndash; Процесс  макрогенерирования кода</h3>
</div> 
<div class="Text_Style">
<p>Усложним задачу и рассмотрим трансформацию программы с использованием макросредств языка ассемблера. Произведем генерирование полигармонического сигнала, состоящего из двух гармонических сигналов.</p>
<p>Программирование с использованием макросредств ассемблера показано на примере программы, реализующей алгоритм генерирования полигармонического сигнала, подробно рассматриваемый в лекции 2.7. Полигармоника формируется из синусоидальных сигналов гармоник 3,48 с единичной амплитудой и фазой 121 градус и 7,25 с единичной амплитудой и фазой 3 градуса.  </p>
<blockquote>
  <blockquote>&nbsp;</blockquote>
</blockquote>
</div>
<div>
  <div class="Text_Style">
    <blockquote>
      <blockquote>
        <p> .mmregs<br>
.def	_c_int00	; Определяем переменную, определяющую стартовый адрес<br>
.text<br>
<br>
sine_gen	.macro	freq_c, faza_c, n<br>
.text<br>
;		инициализация<br>
ld		#faza:n:, DP<br>
rsbx	sxm<br>
rsbx	frct <br>
        </p>
        <p> ; адрес коэффициента для интерполяции <br>
          stm		#faza:n:+1, AR3 <br>
          ; абсолютная разность между значениями i+1 и i<br>
          stm		#delta:n:, AR4<br>
        </p>
        <p> ;	вычисление синуса<br>
          <br>
          dld		faza:n:, A<br>
          and		#0x0FFF, 16, A<br>
          add		#sine_table, 16, A<br>
          sftl	A, -16, A<br>
          stlm	A, AR2<br>
          nop<br>
          nop <br>
          ld		*AR2+, 16, B<br>
          ld		*AR2, 16, A<br>
          sub		B, A<br>
          sth		A, *AR4<br>
          sfta	B, 1, B<br>
          macsu	*AR3, *AR4, B<br>
          sfta	B, -1, B<br>
          ;	значение синуса 32 разряда в акуммуляторе B<br>
        sth		B, sin_val:n:</p>
        <p> ;	вычисление следующее значение фазы<br>
          dld		faza:n:, A<br>
          dadd	freq:n:, A<br>
          dst		A, faza:n:<br>
  <br>
          .data<br>
          .align		2<br>
          faza:n:		.long		faza_c <br>
          freq:n:		.long		freq_c <br>
          delta:n:	.word		0 <br>
          sin_val:n:	.word		0 <br>
  <br>
          .text<br>
          .endm<br>
        </p>
        <p> ; Начинаем сегмент кода<br>
          _c_int00: <br>
          stm		#sine_bufer, AR5<br>
          stm		#4096-1, BRC<br>
          rptb	end_block<br>
  <br>
          sine_gen	3*65536+30000, 4096*3*65536/360, 1<br>
          sine_gen	7*65536+16384, 4096*121*65536/360, 2<br>
  <br>
          ssbx	sxm<br>
          nop<br>
          ld		sin_val1, B<br>
          add		sin_val2, B<br>
          sfta	B, -1, B</p>
        <p>end_block<br>
          stl		B, *AR5+</p>
        <p> nop</p>
        <p> .data<br>
        </p>
        <p>sine_table <br>
          .include	&quot;sine_table1.asm&quot;<br>
          sine_bufer<br>
          .space		4096*16 <br>
  <br>
          .end</p>
<pre>&nbsp;</pre>
      </blockquote>
    </blockquote>
  </div>
  <div class="Text_Style">
    <p>Результат формирования синусоидального сигнала гармоники 7.25 представлен на рисунке 1.2.6. (половина выборки - 2048 отсчетов из 4096)</p>
  </div>
  <div>
    <h3 align="center"><a name="Рис1.2.8"></a><img src="../../images/Ris03_3.jpg" width="90%"></h3>
  </div>
<h3 align="center">Рисунок 1.2.8 &ndash; Использование макроопределения для формирования синусоидального сигнала на примере  формирования полигармонического сигнала</h3></div> 
<div class="Text_Style">
  <h1>Использование стандартных библиотек</h1>
</div>
<div class="Text_Style">
<p>Разработанные программные модули,  включая, в том числе, и макроопределения, представляют собой несомненную  ценность для любого разработчика программного обеспечения работающего в  конкретной предметной области.<br>
  Для решения проблемы доступности и  простого их применения разработанных программных модулей при многократном их  использовании в различных проектах рекомендуется использовать возможность  архивации разработанных программных модулей в библиотеках различного типа.<br>
  В предыдущем примере было разработано  макроопределение для генерирования произвольной гармоники синусоидального  сигнала.<br>
  Рассмотрим алгоритм создания библиотеки  макроопределений.<br>
  1. Формируем файл содержащий  макроопределение с расширение *.asm. В качестве  имени удобно использовать имя макроопределения. Содержимое файла представлено на рисинке 1.2.9.</p></div>

  <div>
    <h3 align="center"><a name="Рис1.2.9"></a><img src="../../images/Ris03_4.jpg" width="90%"></h3>
  </div>
<div><h3 align="center">Рисунок 1.2.9 &ndash; Формирование файла sine_gen.asm с текстом макроопределения sine_gen для формирования гармонического сигнала</h3></div> 
<div class="Text_Style"><p>2. Включаем макроопределение в новую создаваемую библиотеку или добавляем макроопределение в существующую, например, выполнив командную строку (рисунок 1.2.10). Можно создавать библиотеки используя графический интерфейс. </p></div>

  <div>
    <h3 align="center"><a name="Рис1.2.10"></a><img src="../../images/Ris03_5.jpg" width="90%"></h3>
  </div>
<div><h3 align="center">Рисунок 1.2.10 &ndash; Создание библиотеки mylib.lib содержащей макроопределение sine_gen для формирования гармонического сигнала</h3></div> 

<div class="Text_Style">
<p>3. Подключаем библиотеку с использование директивы &quot;.mlib	&quot;mylib.lib&quot;&quot; и исполюзуем макрокоманду sine_gen. </p>
<p>Пример программы с использованием макробиблиотеки  показано на примере программы, реализующей алгоритм генерирования полигармонического сигнала. Полигармоника формируется из синусоидальных сигналов гармоник 20,76 с единичной амплитудой и фазой 0 градусов и 7,25 с единичной амплитудой и фазой 90 градусов. Результат работы программы представлен на рисунке 1.2.11.
  </p>
<blockquote>
    <blockquote>&nbsp;</blockquote>
</blockquote>
</div>
<div>
  <div class="Text_Style">
    <blockquote>
      <blockquote>
        <p> .mmregs<br>
.mlib	&quot;mylib.lib&quot;</p>
        <p> .def	_c_int00	; Определяем переменную, определяющую стартовый адрес<br>
          .text<br>
  <br>
         ; Начинаем сегмент кода<br>
          _c_int00: <br>
          stm		#sine_bufer, AR5<br>
          stm		#4096-1, BRC<br>
          rptb	end_block<br>
  <br>
          sine_gen	20*65536+50000, 4096*0*65536/360, 1<br>
          sine_gen	7*65536+16384, 4096*90*65536/360, 2<br>
  <br>
          ssbx	sxm<br>
          nop<br>
          ld		sin_val1, B<br>
          add		sin_val2, B<br>
        sfta	B, -1, B</p>
        <p>end_block<br>
        stl		B, *AR5+</p>
        <p> nop</p>
        <p> .data<br>
        sine_table <br>
          .include	&quot;sine_table1.asm&quot;<br>
          sine_bufer<br>
          .space		4096*16 <br>
  <br>
        .end      </p>
      </blockquote>
    </blockquote>
  </div>

  <div>
    <h3 align="center"><a name="Рис1.2.11"></a><img src="../../images/Ris03_6.jpg" width="90%"></h3>
  </div>
<div>
  <h3 align="center">Рисунок 1.2.11 &ndash; Использование библиотеки макроопределений mylib.lib на примере  формирования полигармонического сигнала</h3></div> 

<!-- (C) 2017 Shemarov Alexander, BSUIR end-->  


<div align="center">
	<p>
	<input type="button" class="buttonManage" value="&nbsp;Назад&nbsp;" onClick="document.location.href ='../LK02/lk_02.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Перечень тем лекций&nbsp;" onClick="document.location.href ='../../theory.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Вперед&nbsp;" onClick="document.location.href ='../LK04/lk_04.htm'" />
    </p>
  
<div class="Text_Style"><br></div>
</div>


<!--end-->
<div class="Header_Style">
<table width="100%" border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../../../Оболочка/images/background.jpg">
	<Tr>
    <td align=center colspan=2><var class="Header_Style"><A HREF="../../../index.htm">Оглавление</A> | <A HREF="../../../Программа/ППОВСРВ_программа_2017.htm" >Программа</A> | <a href="../../../Теория/theory.htm">Теория</a> | <a href="../../../Практика/practice.htm">Практика</a> |<A HREF="../../../Контроль_знаний/test.htm">Контроль знаний</A> | <A HREF="../../../Об авторах/author.htm">Об авторах</A></var></var> </td>
  <Tr>
   <td align=center><a href="https://www.bsuir.by/" title="Официальный сайт БГУИР" target="_blank">(С) БГУИР</a></td>
  </tr>
</table></div>

</BODY></HTML>