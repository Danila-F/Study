<!-- (C) 2010 Nesterenkov Sergey, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="../../../Оболочка/css/style2.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Теория по дисциплине &quot;Программирование проблемно-ориентированных вычислительных средств реального времени&quot;</title>
<base target="_top">

<base target="_self">
<style type="text/css">
body,td,th { font-family: Times New Roman, Times, serif; }
p {margin-left: 5%; margin-right: 5%; }
</style></HEAD>

</HEAD><BODY>
<div class="Header_Style">
<table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../../Оболочка/images/background.jpg">
  <tr> 
    <td width="13%" rowspan=3 align="center" ><img src="../../../Оболочка/images/logo_new.jpg" width=117 align="middle"></td>
  <tr> 
    <td width="70%" colspan=2 align="center" valign="middle"> <H1 align="center" >&nbsp;</H1>
      <H1 align="center" >Электронный ресурс по учебной дисциплине<BR>
        "Программирование проблемно-ориентированных вычислительных средств реального времени"<BR> 
        для специальности: </H1>
<p>1-40 02 02 "Электронные вычислительные средства"
</p></td>
    <td width="12%" rowspan=3 align="center" ><img src="../../images/theory.jpg" width="146" height="85"></td>
  <Tr>
    <td align=center colspan=2><var class="Header_Style"><A HREF="../../../index.htm">Оглавление</A> | <A HREF="../../../Программа/ППОВСРВ_программа_2017.htm" >Программа</A> | <a href="../../../Теория/theory.htm">Теория</a> | <a href="../../../Практика/practice.htm">Практика</a> | <A HREF="../../../Контроль_знаний/test.htm">Контроль знаний</A> | <A HREF="../../../Об авторах/author.htm">Об авторах</A></var></var> </td>
  <tr>
</table></div>



<!--start-->
	<div class="mainTitle" align="center">
	  <h1>Лекция № 2.6</h1>
</div>
	<div>
	  <h3 align="center"><strong>Раздел 2.  Программная реализация основных алгоритмов цифровой обработки сигналов:  формирование сигналов, цифровая фильтрация, быстрое преобразование Фурье</strong>      </h3>
      <p><strong>2.1&nbsp;&nbsp;&nbsp; Программирование синусоидальных сигналов  аналитическими и табличными методами (4 часа)</strong><br>
        <strong><em>Лекция № 2.6</em></strong><br>
        Методы  программирования синусоидальных сигналов. Аналитические методы программирования  синусоидальных сигналов. <br>
        Табличные методы программирования  синусоидальных сигналов. Прямой и интерполяционный табличные методы  программирования синусоидальных сигналов.<br>
      </p>
</div>

<div align="center">
    <p>
    <input type="button" class="buttonManage" value="&nbsp;Назад&nbsp;" onClick="document.location.href ='../LK05/lk_05.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Перечень тем лекций&nbsp;" onClick="document.location.href ='../../theory.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Вперед&nbsp;" onClick="document.location.href ='../LK07/lk_07.htm'" />
    </p>
</div>

<!-- (C) 2017 Shemarov Alexander, BSUIR begin-->  

<div class="Text_Style">
  <h1>Методы программирования синусоидальных сигналов</h1>
  <p>Программирование синусоидальных  (гармонических) сигналов с целью формирования сигнала с требуемыми параметрами  для использования в работе систем, функционирующих в масштабе реального  времени, сводится к решению математической задачи вычисления значения элементарной  периодической функции с заданной точностью. Существует несколько основных  методов вычисления элементарных периодических функций с использованием  электронных вычислительных средств: </p>
  <ul align="left">
    <ul>
      <ul>
        <li>разложение в ряд  Тейлора (степенные полиномы);</li>
        <li>аппроксимация с  помощью различных полиномов;</li>
        <li>табличные методы;</li>
        <li>рациональные  приближения элементарных функций;</li>
        <li>использование  цепных дробей;</li>
        <li>итерационные  (рекуррентные) методы.</li>
      </ul>
    </ul>
  </ul>
  <p>Степенные полиномы (отрезок ряда  Тейлора, полином Чебышева и т.д.) вычисляются в компьютерах чаще всего по схеме  Горнера. При этом требуется выполнить&nbsp; n операций умножения и&nbsp; n операций  сложения (n - степень полинома). К сожалению, ряд Тейлора очень  медленно сходится для некоторых элементарных функций (натуральный логарифм,  обратные тригонометрические и гиперболические функции). Поэтому время  вычисления может быть достаточно большим, а инструментальная погрешность может увеличиваться.  Методическая погрешность этого метода монотонно увеличивается с ростом  аргумента, и поэтому приходится предварительно сводить аргумент в более узкую  область с помощью соответствующих преобразований. Достоинством разложения в ряд  Тейлора (в отличие от аппроксимации полинома Чебышева) является то, что можно  вычислять коэффициенты членов ряда непосредственно при вычислении функций и не  хранить их в памяти компьютера. Однако при этом возрастает время вычисления элементарной  функции. Единообразие вычисления всех элементарных функций трудно обеспечить  из-за плохой сходимости ряда для некоторых функций.<br>
    Метод полиномиальной аппроксимации  используется в компьютерах наиболее часто. Он характеризуется достаточно  высоким единообразием вычисления всех элементарных функций, однако при этом в  памяти необходимо хранить большое количество коэффициентов всех полиномов. Для  ускорения сходимости полинома аргумент предварительно сводится в более узкую  область. Методическая погрешность знакопеременна и равномерно распределена на  интервале изменения аргумента. Для вычисления элементарной функции с  произвольной разрядностью в некоторых компьютерах используется комбинированный  таблично-полиномиальный алгоритм. Приближение любой элементарной функции в  приведенном интервале ведется с помощью подпрограмм не одним ортогональным  полиномом, а их набором, каждый из которых применяется на подинтервалах с  возрастанием степени аппроксимации от одного подинтервала к следующему.<br>
    Табличные методы основаны главным  образом на кусочно-линейной и криволинейной аппроксимации. Для вычисления элементарной  функции этим методом требуется выполнить малое число арифметических операций,  однако объем таблиц и время поиска в них может быть большим. Поэтому этот метод  применяется в компьютерах с относительно небольшой разрядностью слов.<br>
    При методе рационального приближения элементарной  функции функцию представляют в виде отношения двух полиномов, причем число  членов в каждом полиноме намного меньше, чем при соответствующем разложении в  ряд Тейлора. Однако коэффициенты полиномов должны обязательно храниться в памяти.  Для вычисления элементарной функции следует вычислить два полинома и выполнить  операцию деления.<br>
    Метод цепных дробей характеризуется  единообразием вычисления всех элементарных функций, при этом количество  констант мало. По сравнению с методом степенных полиномов при этом методе число  шагов меньше, однако, на каждом шаге выполняется операция деления, занимающая  много времени. Хотя для цепных дробей область сходимости более широкая, чем для  ряда Тейлора, но с ростом аргумента резко возрастает необходимое число звеньев  дроби. Это заставляет приводить аргументы к интервалу, не более широкому, чем интервал,  используемый при разложении&nbsp; в ряд  Тейлора. Оценка погрешности является сложной. Метод используется в случаях, когда  требуемое быстродействие не является критически важным параметром.<br>
    Итерационные методы предполагают  вычисление последовательных приближений функции по итерационной формуле.&nbsp; Необходимость, в ряде случаев, выполнять  операции деления и умножения на каждой итерации уменьшает скорость вычислений.  Оценка погрешности удобна, алгоритмы вычисления некоторых функций (базового  набора) достаточно единообразны. Загрузка памяти наименьшая, так как константы  можно вычислить непосредственно перед расчетом функций по той же схеме,  например для инициализации таблиц вычисляемых функций. <br>
    Широко используются эффективные  итерационные алгоритмы вычисления элементарных функций. Эти методы чаще всего  называется методом &laquo;цифра за цифрой&raquo;, так как после&nbsp; итераций алгоритма получается значение  функции с точностью до единицы i-го разряда.  Однако следует заметить, что в отличие от традиционных методов &laquo;цифра за  цифрой&raquo; (например, деление) в данном методе на каждом шаге итерации получается полноразрядный  приближенный результат, а приращение прибавляется к нему, так что на любом шаге  из-за переносов может измениться любая цифра результата, вплоть до старшего  разряда. Тем не менее, этот метод обычно называется методом &laquo;цифра за цифрой&raquo;.  Важным преимуществом этого метода является его эффективность для  непосредственного вычисления почти всех элементарных функций. С помощью этого  метода можно также находить корни полиномов, выполнять преобразования координат  и преобразования систем счисления чисел. Погрешность вычислений легко  компенсируется с помощью дополнительных разрядов. Области сходимости достаточно  широкие, а для некоторых функций вообще не требуется приведения аргумента. Так  как алгоритмы метода построены на простых операциях сдвига и сложения, то их  аппаратная реализация является простой и эффективной. Метод позволяет вычислять  большинство элементарных функций за время трех операций деления (если не  учитывать приведение аргумента), причем его алгоритмам присущ внутренний  параллелизм, позволяющий еще более повысить быстродействие за счет совмещения  операций в одном процессоре. Недостатками метода является большое количество  используемых констант и применение операционного устройства со специфической  структурой.<br>
  Ниже мы рассмотрим использование некоторых методов при решении  задачи вычисления гармонических и других элементарных функций.</p>
  <p>&nbsp;</p>
</div>

<div class="Text_Style">
<h1>Аналитические методы программирования  синусоидальных сигналов</h1>
<h2>Рекуррентно-аналитический метод на основе формул суммы двух углов</h2>
</div>
<div class="Text_Style">
	  <p>Существует несколько аналитических (вычислительных)  методов формирования синусоидальных сигналов. Один из таких методов основан на  формулах суммы двух углов:</p>
      <table align="center" width="80%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td width="10%" valign="top">&nbsp;</td>
          <td width="70%" valign="center" align="center">			sin(&alpha;+&beta;) = sin(&alpha;)&middot;cos(&beta;)+cos(&alpha;)&middot;sin(&beta;),<br>
			cos(&alpha;+&beta;) = cos(&alpha;)&middot;cos(&beta;)&ndash;sin(&alpha;)&middot;sin(&beta;).<br><br></td>
          <td width="10%" valign="center" align="right">(2.1.1)</td>
        </tr>
      </table>
      <p>Этот метод применим для последовательной генерации  отсчетов одной синусоиды и позволяет вычислить очередной отсчет функции,  например sin(an)=sin(a(n-1)+a)  через предыдущий sin(a(n-1)).<br>
        Использовав a(n-1)  в качестве &alpha; и a  в качестве &beta; и обозначив S1=sin(a),  C1=cos(a), Sn(n)=sin(an), Cn(n)=cos(an),  получим следующие выражения для вычисления очередных значений синуса и  косинуса:</p>
      <table align="center" width="80%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td width="10%" valign="top">&nbsp;</td>
          <td width="70%" valign="center" align="center">			Sn(n) = C1&middot;Sn(n-1)+S1&middot;Cn(n-1),<br>
			Cn(n) = C1&middot;Cn(n-1)&ndash;S1&middot;Sn(n-1).<br><br></td>
          <td width="10%" valign="center" align="right">(2.1.2)</td>
        </tr>
      </table>
      <p>Исходными данными для вычисления первой гармоники (с  минимальной возможной частотой) являются следующие значения: Sn(0)=0, Cn(0)=1  &ndash; значения синуса и косинуса для нулевого аргумента; N&nbsp;&ndash;  длина выборки (число отсчетов в первой гармонике); a=2&Pi;/N  &ndash; минимальное приращение аргумента и S1=sin(2&Pi;/N), C1=cos(2&Pi;/N) &ndash; значения синуса и косинуса для минимального аргумента.<br>
        На рис.&nbsp;2.1.1 показан пример синусоиды с периодом 8 отсчетов (N=8).<br>
<h3 align="center"><a name="fig1"></a><img src="../../images/ris010101_a.gif" alt="Рис.2.1" width="610" height="273"></h3>
<h3 align="center">Рисунок 2.1.1 &ndash; Синусоида с периодом 8 отсчетов</h3>
<p>Учитывая, что исходными значениями для k-й гармоники являются начальный угол &beta;=ak, Sk=sin(ak) и Ck=cos(ak), для их вычисления можно использовать те же  самые формулы:</p>
      <table width="80%" align="center" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td width="10%" valign="top">&nbsp;</td>
          <td width="70%" valign="center" align="center">			Sk(k) = C1&middot;Sk(k-1)+S1&middot;Ck(k-1),<br>
			Ck(k) = C1&middot;Ck(k-1)&ndash;S1&middot;Sk(k-1).<br><br></td>
          <td width="10%" valign="center" align="right">(2.1.3)</td>
        </tr>
      </table>
      <p>Исходными  данными для вычисления, как и в выражении  (1.2), являются значения Sk(0)=0 и Ck(0)=1.<br>
        Расположив данные в памяти следующим образом: Cn, Sn, Ck, Sk,  C1, S1, можно использовать одну и ту же подпрограмму с  косвенной адресацией для вычисления как отсчетов очередной гармоники Sn и Cn,  так и начальных значений Sk и Ck.<br>
        Для чего вначале устанавливаем указатель (адрес во  вспомогательном регистре) на Ck и  вычисляем очередное значение Ck и Sk, а затем на Cn и вычисляем нужное число отсчетов очередной  гармоники Sn и Cn:</p>
      <table width="80%" align="center" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td width="10%" valign="top">&nbsp;</td>
          <td width="70%" valign="center" align="center">			Sn(n) = Ck&middot;Sn(n-1)+Sk&middot;Cn(n-1),<br>
			Cn(n) = Ck&middot;Cn(n-1)&ndash;Sk&middot;Sn(n-1).<br><br></td>
          <td width="10%" valign="center" align="right">(2.1.4)</td>
        </tr>
      </table>
	  <p>При  программировании синусоиды данным методом необходимо учесть следующие  замечания:</p>
      <ul>
        <ul>
          <ul>
            <li>используя два вспомогательных регистра и  двухоперандные команды (Xmem,  Ymem), вычисление  синуса (косинуса) можно выполнить тремя командами;</li>
            <li>поскольку ассемблер TMS320VC5402 не имеет  директив для задания дробных чисел, то дробные числа (формат Q15) переводятся в  целые путем умножения на 32768 и используется директива .word;</li>
            <li>поскольку не существует кода для положительной единицы,  то для задания <strong>cos(0) </strong>используется  приближенное значение 7FFFh = 1-2<sup>-15</sup>;</li>
            <li>для того чтобы формируемая синусоида  (косинусоида) не затухала, начальное значение <strong>C1=cos(2&Pi;/N) </strong>увеличивается  на одну или две единицы младшего разряда и вычисления выполняются в старшей  части аккумулятора при установленном режиме коррекции переполнения.</li>
          </ul>
        </ul>
      </ul>
	</div>
	<div class="Text_Style"><h2>Рекуррентно-аналитический метод на основе формул двойного угла</h2></div>
<div class="Text_Style">
	  <p>Другой аналитический метод основан на формулах  двойного угла:</p>
      <table width="80%" align="center" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td width="10%" valign="top">&nbsp;</td>
          <td width="70%" valign="center" align="center">			sin(2&alpha;) = 2&middot; sin(&alpha;)&middot;cos(&alpha;),<br>
		  cos(2&alpha;) = cos<sup>2</sup>(&alpha;)&ndash;sin<sup>2</sup>(&alpha;)=1&shy;&ndash;2&middot; sin<sup>2</sup>(&alpha;)=2&middot; cos<sup>2</sup>(&alpha;)&ndash;1.<br><br></td>
          <td width="10%" valign="center" align="right">(2.1.5)</td>
        </tr>
      </table>
      <p>Для вычисления косинуса целесообразно использовать  второе выражение, т.к. первое требует возведения в квадрат двух значений, а  третье &ndash; дает не точный результат из-за того, что косинус малого угла близок к  единице.<br>
        Данный метод позволяет вычислить синус и косинус  любого угла, но требует больше затрат для вычисления последовательных отсчетов  синуса и косинуса.<br>
        Суть метода заключается в вычислении очередного  значения аргумента синуса (косинуса) a(n)=a(n-1)+s(k),  где s(k) &ndash; шаг приращения  аргумента (угла) для k-й  гармоники. При этом данный шаг вычисляется по аналогичной формуле s(k)=s(k-1)+a, где a=2&Pi;/N  &ndash; приращение аргумента первой гармоники.<br>
        Для вычисления функции аргумент <strong>a(n)</strong> делится на два m  раз до тех пор, пока не будет выполняться с заданной точностью соотношение sin(&alpha;)=&alpha;,  где &alpha;=a/2<sup>m</sup>. <br>
        После чего,  применив m раз вышеприведенные  формулы (1.5) и использовав в качестве первого приближения sin(&alpha;)&nbsp;=&nbsp;&alpha; и cos<sup>2</sup>(&alpha;)&nbsp;=&nbsp;1&nbsp;&ndash;&nbsp;sin<sup>2</sup>(&alpha;)&nbsp;=&nbsp;1&nbsp;&ndash;&nbsp;&alpha;<sup>2</sup>,  получим значения синуса и косинуса угла <strong>a(n)</strong>.<br>
      Например, для угла 0.0625  рад (0.0625&times;32768=2048=800h) точное значение синуса равно 0.0624593 (2046.7=7FFh),  а косинуса &ndash; 0.9980475 (32704=7FC0h); для угла 0.03125  рад (1024=400h) значение синуса  равно 0.0312449 (1023.8=400h),  а косинуса &ndash; 0.9995117 (32752=7FF0h), и для угла 0.015625  рад (512=200h) значение синуса  равно 0.0156244 (511.9=200h),  а косинуса &ndash; 0.9998779 (32764=7FFCh).</p>
      <p>Поскольку точные значения косинуса малого угла  отличаются от единицы, то для повышения точности расчета следовало бы для его  первого приближения находить значение из выражения cos<sup>2</sup>(&alpha;)&nbsp;=&nbsp;1&nbsp;&ndash;&nbsp;sin<sup>2</sup>(&alpha;).  Но так как вычисление квадратного корня трудоемкая операция, то с достаточно  высокой точностью можно получить значение косинуса по формуле cos(&alpha;)&nbsp;=&nbsp;1&nbsp;&ndash;&nbsp;&alpha;<sup>2</sup>/2, что для малых углов дает очень хорошее  приближение. По этой формуле для трех приведенных выше углов получим следующие  значения: 0.9980469 (32704=7FC0h), 0.9995117 (32752=7FF0h) и 0.9998779 (32764=7FFCh). Из приведенных выше расчетов видно, что с  точностью &frac12; младшего разряда мы получим результат при углах, меньших 0.03125 рад или <strong>1,8&deg;</strong> (1024=400h).<br>
      Для нахождения m  и для деления на 2<sup>m</sup>  можно использовать специализированные команды цифрового процессора сигналов (ЦПС)  EXP и<strong> </strong>NORM. Так, например,  если порог равен 400h, а аргумент  равен 0.09473 рад (0C20h), то его необходимо разделить на 2 два раза (m=2),  чтобы получить значение 308h,  меньшее порога. Исходное число после загрузки в старшую часть 40-разрядного  аккумулятор содержит слева 3  незначащих двоичных нуля (000C200000h),  а максимальное число, меньшее порога, &ndash; 5  (0003FF0000h), т.к. незначащие  нули считаются без 8-ми защитных разрядов. Выполнив команду EXP, мы получим в регистре T значение 3,  и, вычтя его из 5, мы получим 2, что равно m, для организации цикла итерационных вычислений по  формуле (1.5) нужно m-1  (т.е. 4-Т), которое загружается во  вспомогательный регистр. А для деления на 2<sup>m</sup>  нужно число -m, которое получается  вычитанием из регистра T значения 5, и, использовав команду NORM, получим в старшей части  аккумулятора значение 0C20h,  деленное на 2<sup>m</sup>,  т.е. 308h. Если в результате  выполнения команды EXP в регистре T получается значение &ge;5, то значит аргумент меньше порога и итерации  выполнять не нужно, а в качестве синуса берется sin(&alpha;)&nbsp;=&nbsp;&alpha;.</p>
  <p>При  программировании синусоиды данным методом необходимо учесть следующие  замечания:</p>
      <ul>
        <ul>
          <ul>
            <li>поскольку аргумент и шаг могут быть &gt;1  (максимальное значение аргумента 6.28=2&Pi;), то  для исключения переполнения необходимо промасштабировать все переменные  (разделить на 8);</li>
            <li>значение m-1=7-Т  (у порога 8 нулей), а для команды NORM  из регистра T нужно вычитать по  прежнему 5, а не 8, чтобы восстановить аргумент (/2<sup>m</sup> и *8);</li>
            <li>вычисления  выполняются без коррекции переполнения (увеличение аргумента), а для коррекции  переполнения (при записи) используется бит SST  в PMST;</li>
            <li>необходима  проверка для малых углов (меньше порога), иначе получится отрицательное число  переполнений.</li>
          </ul>
        </ul>
      </ul>
	  <p>Схема алгоритма формирования последовательности синусоид с возрастающей частотой для двух приведенных выше алгоритмов представлена на рис.&nbsp;2.1.2.</p>
<h3 align="center"><a name="fig2"></a><img src="../../images/ris010101_b.gif" alt="Рис.1.2" width="441" height="817"></h3>
<h3 align="center">Рисунок 2.1.2 &ndash; Схема алгоритма формирования последовательности синусоид</h3>
  <p>При  программировании последовательности синусоиды необходимо учесть следующие  замечания:</p>
  <ul>
    <ul>
        <ul>
          <li>процедура  вычисления начальных значений k-й  гармоники в начале повторяется k  раз (начать с k-гармоники),  а затем 1 раз (перейти к следующей гармонике) или i раз (перейти к гармонике k+i);</li>
          <li>процедура  вычисления начальных значений k-й  гармоники это подпрограмма вычисления очередного значения синуса и косинуса для  первого алгоритма и увеличение приращения аргумента (s(k)=s(k-1)+a) &ndash; для второго;</li>
          <li>во  втором алгоритме необходимо перед каждым вызовом подпрограммы выполнять увеличение  аргумента a(n)=a(n-1)+s(k).</li>
        </ul>
    </ul>
  </ul>
</div>


<div class="Text_Style">
	<h1>Табличные методы программирования  синусоидальных сигналов</h1>
	<h2>Прямой табличный метод</h2></div>
<div class="Text_Style">
	<p>Все табличные методы используют таблицу синуса для  углов от 0 до 360&deg; длиной N  отсчетов, которая представлена в таблице 2.1.1:</p>
    <div align="center">
      <table border="0" cellspacing="0" cellpadding="0">
        <tr><td width="81" valign="top">Таблица</td>
        <td width="440" colspan="3" valign="top">2.1.1 - Таблица синуса из N отсчетов</td>
        </tr>
	</table>
      <table border="1" cellspacing="0" cellpadding="0">
        <tr>
          <td width="102" colspan="2" valign="center" align="center"><strong>ИНДЕКС</strong></td>
          <td width="132" valign="center" align="center"><strong>УГОЛ</strong></td>
          <td width="287" valign="center" align="center"><strong>ТАБЛИЦА СИНУСА</strong></td>
        </tr>
        <tr>
          <td width="102" colspan="2" valign="top"><p align="center">0</p></td>
          <td width="132" valign="top"><p>0&times;360&deg;/N</p></td>
          <td width="287" valign="top"><p>S[0] = sin(0&deg;/N)</p></td>
        </tr>
        <tr>
          <td width="102" colspan="2" valign="top"><p align="center">1</p></td>
          <td width="132" valign="top"><p>1&times;360&deg;/N</p></td>
          <td width="287" valign="top"><p>S[1] = sin(360&deg;/N)</p></td>
        </tr>
        <tr>
          <td width="102" colspan="2" valign="top"><p align="center">2</p></td>
          <td width="132" valign="top"><p>2&times;360&deg;/N</p></td>
          <td width="287" valign="top"><p>S[2] = sin(720&deg;/N)</p></td>
        </tr>
        <tr>
          <td width="102" colspan="2" valign="top"><p align="center">&hellip;</p></td>
          <td width="132" valign="top"><p>&hellip;</p></td>
          <td width="287" valign="top"><p>&hellip;</p></td>
        </tr>
        <tr>
          <td width="102" colspan="2" valign="top"><p align="center">N-2</p></td>
          <td width="132" valign="top"><p>(N-2)&times;360&deg;/N</p></td>
          <td width="287" valign="top"><p>S[N-2] = sin((N-2)&times;360&deg;/N)</p></td>
        </tr>
        <tr>
          <td width="102" colspan="2" valign="top"><p align="center">N-1</p></td>
          <td width="132" valign="top"><p>(N-1)&times;360&deg;/N</p></td>
          <td width="287" valign="top"><p>S[N-1] = sin((N-1)&times;360&deg;/N)</p></td>
        </tr>
      </table>
    </div>
    <p>Данные такой таблицы позволяют получить точные  значения синуса с относительными частотами &omega;<sub>k</sub> = 2&Pi;k/N  кратными минимальной частоте (частоте первой гармоники) &omega;<sub>1</sub> = 2&Pi;/N,  где k &ndash; номер гармоники, равный  шагу в таблице (целое число).<br>
      Но данная таблица позволяет также с некоторым  приближением сформировать синусоидальный сигнал с частотой не кратной &omega;<sub>1</sub>. Используя индекс в таблице как угол и параметр &Delta; (действительное число) как  величину шага, прямой табличный метод может быть записан в виде выражения:</p>
<table align="center" width="80%" border="0" cellspacing="0" cellpadding="0"><tr><td width="10%">&nbsp;</td>
<td width="70%" valign="center" align="center">S[Int{mod(&Delta;&middot;n,N)}]&nbsp;&nbsp;&nbsp; для n = 1, 2, 3, 4, &hellip;<br><br></td>
<td width="10%" valign="center" align="right">(2.1.6)</td></tr></table>
    <p>где Int(a) &ndash; целая  часть от числа a, mod(a,b) &ndash; остаток  при делении нацело a/b (т.е.  значение в интервале от 0 до N-1).<br>
      Это можно проиллюстрировать рисунком&nbsp;2.1.3:</p>
<h3 align="center"><a name="fig3"></a><img src="../../images/ris010102_a.gif" alt="Рис.1.3" width="566" height="266"></h3>
<h3 align="center">Рисунок 2.1.3 &ndash; Синусоида с дробным шагом аргумента</h3>
    <p>Реальная частота  формируемого сигнала f зависит от  интервала дискретизации t и величины  шага &Delta; и определяется выражением:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = &Delta; / (t&middot;N) [Гц]<br>
      Следует помнить, что  согласно теореме Котельникова &Delta; &ge; N/2 .<br>
      На рисунке N  = 8, &Delta; = 0.6 и если t =  0.000125 с, то частота сигнала будет равна:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = 0.6 / (8&middot;0.000125) Гц = 600 Гц <br>
      Алгоритм формирования синусоиды заключается в использовании  дробных чисел при вычислении индекса, но для индексации в таблице используется  только целая часть. Число разрядов целой части должно соответствовать длине  таблицы, а дробной &ndash; числу промежуточных гармоник. Например для таблицы из 8-ми  точек и трех промежуточных гармоник (шаг &frac14;) необходимо 3 разряда в целой части  и два в дробной.<br>
      Недостатком метода являются  довольно большие нелинейные искажения, возникающие из-за того, что энергия  сигнала распределяется между основной гармоникой с частотой f и  гармоническими (nf) и субгармоническими (nf/m)  составляющими (где n и m -&nbsp; целые числа).<br>
      Полные нелинейные искажения (Total Harmonic Distortion &ndash; THD ) определяются выражением:<br><br>
  <div align="center"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>THD = энергия паразитных гармоник / полная энергия сигнала</b></p></div> 
  <p> Чем больше отсчетов в таблице, тем меньше нелинейные  искажения. Значения величин нелинейных искажений в зависимости от длины таблицы  и шага приведено в таблице 2.1.2.</p>
	<div align="center">
	<table align="center" border="0" cellspacing="0" cellpadding="0">
		<tr><td width="77" colspan="2" valign="top">Таблица&nbsp;</td>
	  <td width="390" colspan="3" valign="top">2.1.2 - Значения THD для различных приращений</td></tr>
	</table>
	<table align="center" border="1" cellspacing="0" cellpadding="0">
        <tr>
		<td width="76" rowspan="2" align="center"><strong>&Delta;</strong></td>
		<td width="381" colspan="3" valign="top" align="center">Значение&nbsp; THD&nbsp; для таблицы длиной</td>
        </tr>
        <tr>
          <td width="127" valign="top" align="center">32</p></td>
          <td width="127" valign="top" align="center">64</td>
          <td width="127" valign="top" align="center">128</td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 2.00</p></td>
          <td width="127" valign="top"><p>0.00000024</p></td>
          <td width="127" valign="top"><p>0.00000048</p></td>
          <td width="127" valign="top"><p>0.00000054</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 2.25</p></td>
          <td width="127" valign="top"><p>0.00300893</p></td>
          <td width="127" valign="top"><p>0.00075269</p></td>
          <td width="127" valign="top"><p>0.00018859</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 2.50</p></td>
          <td width="127" valign="top"><p>0.00240751</p></td>
          <td width="127" valign="top"><p>0.00060219</p></td>
          <td width="127" valign="top"><p>0.00015080</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 2.75</p></td>
          <td width="127" valign="top"><p>0.00300917</p></td>
          <td width="127" valign="top"><p>0.00075239</p></td>
          <td width="127" valign="top"><p>0.00018835</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 3.00</p></td>
          <td width="127" valign="top"><p>0.00000024</p></td>
          <td width="127" valign="top"><p>0.00000018</p></td>
          <td width="127" valign="top"><p>0.00000012</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 8.25</p></td>
          <td width="127" valign="top"><p>0.00300924</p></td>
          <td width="127" valign="top"><p>0.00075204</p></td>
          <td width="127" valign="top"><p>0.00018889</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>11.625</p></td>
          <td width="127" valign="top"><p>0.00315807</p></td>
          <td width="127" valign="top"><p>0.00079078</p></td>
          <td width="127" valign="top"><p>0.00020128</p></td>
        </tr>
      </table>
    </div>
	</div>
	<div class="Text_Style"><h2>Табличный метод с линейной интерполяции</h2></div>
<div class="Text_Style">
	<p>Данный метод  является модификацией предыдущего и в его основе лежит точно такая же таблица  синуса и обычная линейная интерполяция функции между двумя точками.<br>
Данный метод описывается выражением <br>
sin(2&Pi;(i+d)/N) &asymp; sin(2&Pi;i/N) + d&middot;[sin(2&Pi;(i+1)/N)  &ndash; sin(2&Pi;i/N)] = S(i) + d&middot;[S(i+1) &ndash; S(i)]<br>
где  i &ndash; целая часть аргумента (индекс в таблице синуса), а d &ndash; дробная часть (коэффициент пропорциональности).<br>
Данный метод может быть проиллюстрирован рисунком 2.1.4:</p>
<h3 align="center"><a name="fig2"></a><img src="../../images/ris010102_b.gif" alt="Рис.2.4" width="582" height="237"></h3>
<h3 align="center">Рисунок 2.1.4 &ndash; Синусоида с дробным шагом аргумента и интерполяцией</h3>
    <p>Значения величин нелинейных искажений для данного  метода в зависимости от длины таблицы и шага приведены в следующей таблице (как  видно из таблицы&nbsp;2.1.3, уже при 128 точках значение коэффициента нелинейных  искажений в этом случае на несколько порядков меньше чем в предыдущем).</p>
    <div align="center">
      <table align="center" border="0" cellspacing="0" cellpadding="0">
        <tr><td width="77" valign="top">Таблица&nbsp;</td>
        <td width="392" colspan="3" valign="top">2.1.3 - Значения THD для разных приращений</td></tr>
	</table>
      <table border="1" cellspacing="0" cellpadding="0">
        <tr>
          <td width="76" rowspan="2" align="center"><strong>&Delta;</strong></td>
          <td width="381" colspan="4" valign="top" align="center">Значение THD для таблицы длиной</td>
        </tr>
        <tr>
          <td width="127" valign="top" align="center">32</td>
          <td width="127" valign="top" align="center">64</td>
          <td width="127" valign="top" align="center">128</td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 2.00</p></td>
          <td width="127" valign="top"><p>0.00000024</p></td>
          <td width="127" valign="top"><p>0.00000048</p></td>
          <td width="127" valign="top"><p>0.00000054</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 2.25</p></td>
          <td width="127" valign="top"><p>0.00169343</p></td>
          <td width="127" valign="top"><p>0.00018884</p></td>
          <td width="127" valign="top"><p>0.00000054</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 2.50</p></td>
          <td width="127" valign="top"><p>0.00135476</p></td>
          <td width="127" valign="top"><p>0.00015055</p></td>
          <td width="127" valign="top"><p>0.00000012</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 2.75</p></td>
          <td width="127" valign="top"><p>0.00169379</p></td>
          <td width="127" valign="top"><p>0.00018771</p></td>
          <td width="127" valign="top"><p>0.00000101</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 3.00</p></td>
          <td width="127" valign="top"><p>0.00000024</p></td>
          <td width="127" valign="top"><p>0.00000018</p></td>
          <td width="127" valign="top"><p>0.00000012</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>&nbsp; 8.25</p></td>
          <td width="127" valign="top"><p>0.00169361</p></td>
          <td width="127" valign="top"><p>0.00018806</p></td>
          <td width="127" valign="top"><p>0.00000006</p></td>
        </tr>
        <tr>
          <td width="76" valign="top"><p>11.625</p></td>
          <td width="127" valign="top"><p>0.00177808</p></td>
          <td width="127" valign="top"><p>0.00019815</p></td>
          <td width="127" valign="top"><p>0.00000155</p></td>
        </tr>
      </table>
    </div>
    <p>Для вычисления коэффициента  нелинейных искажений можно воспользоваться выражением:</p>
	<div align="center"><b>THD = (E(total)&ndash;E(fundamental)) / E(total)</b> ,</div>
      <p>где E(total)  и E(fundamental) значения полной энергии и энергии основной гармоники  сигнала соответственно. Расчет энергии сигнала необходимо вести на интервале,  включающем целое число гармоник. Например при шаге &Delta;=1,5 и длине таблицы 128 число  обрабатываемых отсчетов n должно быть таким, чтобы  величина n&nbsp;&Delta; была кратна 128.  Минимальное значение n=256 (256&times;1,5=384=128&times;3). В общем случае, если &Delta;=А/В, где А и В целые  числа, минимальное значение  n будет  равно B&times;N точек. Полная энергия  сигнала считается по формуле</p>
  <h3 align="center"><img src="../../images/for010102_a.gif" alt="Фор.1.1" width="219" height="69">,</h3>
  <p>а энергия основной гармоники по формуле </p>
<h3 align="center"><img src="../../images/for010102_b.gif" alt="Фор.1.2" width="535" height="54">,</h3>
      <p>где  X(k) &ndash; изображение Фурье k-й  гармоники</p>
<h3 align="center"><img src="../../images/for010102_c.gif" alt="Фор.1.3" width="295" height="69">.</h3>
      <p>Значения THD,  приведенные в таблицах, были рассчитаны по вышеприведенным формулам на ПЭВМ с  использованием арифметики с плавающей запятой с двойной точностью.
      </p>
</div>

<!-- (C) 2017 Shemarov Alexander, BSUIR end-->  

<div align="center">
	<p>
	<input type="button" class="buttonManage" value="&nbsp;Назад&nbsp;" onClick="document.location.href ='../LK05/lk_05.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Перечень тем лекций&nbsp;" onClick="document.location.href ='../../theory.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Вперед&nbsp;" onClick="document.location.href ='../LK07/lk_07.htm'" />
    </p>
  
<div class="Text_Style"><br></div>
</div>


<!--end-->



<div class="Header_Style">
<table width="100%" border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../../../Оболочка/images/background.jpg">
	<Tr>
    <td align=center colspan=2><var class="Header_Style"><A HREF="../../../index.htm">Оглавление</A> | <A HREF="../../../Программа/ППОВСРВ_программа_2017.htm" >Программа</A> | <a href="../../../Теория/theory.htm">Теория</a> | <a href="../../../Практика/practice.htm">Практика</a> |<A HREF="../../../Контроль_знаний/test.htm">Контроль знаний</A> | <A HREF="../../../Об авторах/author.htm">Об авторах</A></var></var> </td>
  <Tr>
   <td align=center><a href="https://www.bsuir.by/" title="Официальный сайт БГУИР" target="_blank">(С) БГУИР</a></td>
  </tr>
</table></div>


</BODY></HTML>