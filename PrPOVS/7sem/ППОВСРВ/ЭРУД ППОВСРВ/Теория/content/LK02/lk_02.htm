<!-- (C) 2010 Nesterenkov Sergey, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="../../../Оболочка/css/style2.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Теория по дисциплине &quot;Программирование проблемно-ориентированных вычислительных средств реального времени&quot;</title>
<base target="_top">

<base target="_self">
<style type="text/css">
body,td,th { font-family: Times New Roman, Times, serif; }
p {margin-left: 5%; margin-right: 5%; }
</style></HEAD>

</HEAD><BODY>
<div class="Header_Style">
<table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../../Оболочка/images/background.jpg">
  <tr> 
    <td width="13%" rowspan=3 align="center" ><img src="../../../Оболочка/images/logo_new.jpg" width=117 align="middle"></td>
  <tr> 
    <td width="70%" colspan=2 align="center" valign="middle"> <H1 align="center" >&nbsp;</H1>
      <H1 align="center" >Электронный ресурс по учебной дисциплине<BR>
        "Программирование проблемно-ориентированных вычислительных средств реального времени"<BR> 
        для специальности: </H1>
<p>1-40 02 02 "Электронные вычислительные средства"
</p></td>
    <td width="12%" rowspan=3 align="center" ><img src="../../images/theory.jpg" width="146" height="85"></td>
  <Tr>
    <td align=center colspan=2><var class="Header_Style"><A HREF="../../../index.htm">Оглавление</A> | <A HREF="../../../Программа/ППОВСРВ_программа_2017.htm" >Программа</A> | <a href="../../../Теория/theory.htm">Теория</a> | <a href="../../../Практика/practice.htm">Практика</a> | <A HREF="../../../Контроль_знаний/test.htm">Контроль знаний</A> | <A HREF="../../../Об авторах/author.htm">Об авторах</A></var></var> </td>
  <tr>
</table></div>



<!--start-->
	<div class="mainTitle" align="center">
	  <h1>Лекция № 1.2</h1>
</div>
	<div>
	  <h3 align="center"><strong>Раздел 1.  Технологии и инструментальные системы программирования проблемно-ориентированных  вычислительных средств реального времени</strong></h3>
      <p><strong>1.2&nbsp;&nbsp;&nbsp; Технология создания программ на ассемблере (4  часа)</strong><br>
        <strong><em>Лекция № 1.2</em></strong><br>
        Модели распределения памяти,  используемые при разработке программ для цифровых процессоров обработки  сигналов. <br>
Структура и сегментирование программы на  ассемблере. Основные элементы, структура предложения, основные группы директив  языка ассемблер.<br>
      </p>
</div>

<div align="center">
	<p>
	<input type="button" class="buttonManage" value="&nbsp;Назад&nbsp;" onClick="document.location.href ='../LK01/lk_01.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Перечень тем лекций&nbsp;" onClick="document.location.href ='../../theory.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Вперед&nbsp;" onClick="document.location.href ='../LK03/lk_03.htm'" />
    </p>
</div>

<!-- (C) 2017 Shemarov Alexander, BSUIR begin-->  
<div class="Text_Style"><h1>Модели распределения памяти,  используемые при разработке программ для цифровых процессоров обработки  сигналов</h1>
</div>
<div class="Text_Style"><p>Исходные файлы  программы подготавливаются на языках программирования, которые поддерживаются  инструментальной средой программирования Texas  Instruments Code  Composer Studio.  Исходный код, написанный на языках высокого уровня, преобразуется в линейный  ассемблерный код, подвергаемый дальнейшей обработке.<br>
Ассемблер и компоновщик создают  объектные файлы, которые могут быть выполнены на ЦПОС TMS320C54x. Формат для  этих объектных файлов называют обобщенным форматом объектных файлов (Common Object File Format - COFF). COFF позволяет  использовать модульное программирование, которое позволяет использовать секции и  сегменты при программировании на ассемблере. Ассемблер и компоновщик предоставляют  программисту набор директив, позволяющий создавать и использовать секции и сегменты,  как единицы программного кода.</p>
<p>Существуют  следующие типы файлов COFF:<br>
COFF0<br>
COFF1<br>
COFF2<br>
У  каждого типа файла COFF существует собственный &nbsp;формат заголовка. Части данных файлов COFF  идентичны. <br>
Ассемблер  и компилятор C создают файлы формата COFF2. Компоновщик может обрабатывать и  создавать все типы файлов COFF. По умолчанию, компоновщик создает файлы типа COFF2.  Можно использовать -v опцию компоновщика, чтобы управлять различными форматами.  Компоновщик использует файлы форматов COFF0 и COFF1 для совместимости с более старшими  версиями ассемблера и компилятора C.</p>
<p><strong>СЕКЦИИ</strong> <br>
Минимальный  модуль объектного файла называется секцией. Секция - блок программы или данные,  которая в результате компоновки программы, в конечном счете, займет смежное  пространство в карте распределения памяти. Каждая секция объектного файла  является отдельным и явным объектом. Объектные файлы COFF всегда содержат три заданные  по умолчанию секции:<br>
<strong>.text &ndash; секция </strong>обычно содержит  исполняемый код;<br>
<strong>.data &ndash; секция </strong>обычно содержит  инициализируемые данные;<br>
<strong>.bss &ndash; секция </strong>обычно  резервирует пространство для неинициализированных переменных.<br>
Кроме того,  ассемблер и компоновщик позволяют создавать, именовать, и компоновать  именованные секции, которые используются как .data, .text и .bss секции.<br>
Есть два  основных типа секций:<br>
<strong>инициализированные  секции &ndash; </strong>содержат  данные или код. Секции .text и .data инициализированы (строго определенные  данные). Поименованные секции, созданные директивой ассемблера с.sect, также  инициализированы.<br>
<strong>неинициализированные  секции &ndash; </strong>резервируют  пространство для неинициализированных данных, используемых в программе. Секция .bss  является неинициализированной; Поименованные секции, созданные директивой ассемблера  с.usect, являются также неинициализированными.<br>
Несколько  директив ассемблера позволяют связывать различные части кода и данных с  соответствующими сегментами. Ассемблер соединяет эти секции во время трансляции,  создавая соответствующий объектный файл, организованный как показано на рисунке  1.2.1.</p></div>

<div><h3 align="center"><a name="Рис1.2.1"></a><img alt="Рис.1.2.1" src="../../images/ris010201_n.png" width="713" height="428"></h3>
<h3 align="center">Рисунок 1.2.1 &ndash; Модель распределения сегментов в разных типах памяти гипотетического процессора</h3></div>

<div class="Text_Style"><p>Одной из функций  компоновщика является функция размещения сегментов в памяти процессора. Эта  функция называют распределением. Поскольку большинство реальных аппаратных систем  включает несколько типов памяти, использование секций и сегментов позволяет использовать  ресурсы памяти более эффективно. Все секции переместимы независимо друг от  друга. Можно разместить любую секцию в любой распределяемый блок памяти.  Например, можно определить секцию, которая содержит подпрограмму, содержащую  инициализированные данные и работающую в оперативной памяти, предварительно разместив  ее в части распределяемой памяти, которая содержит ROM, и после перезагрузить  ее в требуемое адресное пространство оперативной памяти.
</p></div>
<div class="Text_Style"><h1>Структура и сегментирование программы на  ассемблере</h1></div>

<div class="Text_Style">

<p><strong>ИСПОЛЬЗОВАНИЕ  СЕГМЕНТОВ В АССЕМБЛЕРЕ</strong></p></div>

<div class="Text_Style">
<p>Ассемблер идентифицирует части программы на языке ассемблера, которые принадлежат различным сегментам. У ассемблера есть несколько директив, которые поддерживают это распределение:</p>
<ul>
  <ul>
    <ul>
      <li>.bss
      </li>
      <li>.usect
      </li>
      <li>.text
      </li>
      <li>.data
      </li>
      <li>.sect
      </li>
    </ul>
  </ul>
</ul></div>
<div class="Text_Style"><p>.bss и.usect директивы создают неинициализированные сегменты; остальные директивы создают инициализированные сегменты. Можно создать секции любого сегмента, чтобы предоставить программисту возможность более детального распределения памяти. Секции создаются посредством использования .sect и .usect директив. Секции идентифицируются согласно названия сегмента и названия секции, отделенными двоеточием. Если не используется ни одной секции, то ассемблер транслирует программный код в виде одного сегмента .text.</p></div>
<div class="Text_Style"><p><strong>НЕИНИЦИАЛИЗИРОВАННЫЕ  СЕКЦИИ</strong> <br>
Неинициализированные секции просто  резервируют пространство в памяти процессора. Они обычно распределяются в  оперативную память. У этих секций нет никакого фактического информационного  наполнения в объектном файле - они просто резервируют память. Программа может  использовать это пространство в среде выполнения для создания и сохранения  переменных.<br>
Неинициализированные области  данных определяются директивами ассемблера .bss и .usect:<br>
- директива .bss резервирует  пространство в сегменте .bss.<br>
- директива .usect резервирует  пространство в локальной, неинициализированной именованной секции.<br>
Каждый раз, когда вызывается директива  .bss, ассемблер увеличивает резервируемое пространство в соответствующем сегменте.  Использование директивы .usect сообщает ассемблеру &nbsp;о необходимости резервирования дополнительного  пространства в указанной именованной секции. </p>
<p>Синтаксис для  этих директив:</p>
<p><strong>.bss </strong><em>symbol</em>, <em>size  in words</em> [, [<em>blocking flag</em>] [, <em>alignment flag</em>]]<br>
  <em>symbol</em> <strong>.usect </strong>&rdquo;<em>section name</em> &rdquo;, <em>size in words</em> [, [<em>blocking flag</em>] [, <em>alignment flag</em>]]</p>
<p><em>s</em><em>ymbol</em> - указывает на первое слово,  зарезервированное этим символическим именем директивы .bss или usect. Символ  соответствует названию метки резервируемого пространства. На него может  сослаться любая другая секция и он может быть объявлен как глобальный (с  использованием директивы ассемблера .global).<br>
  <em>size  in words</em> - абсолютное выражение.<br>
  Директива .bss резервирует  пространство размером <em>size in words</em> слов  в секции .bss.<br>
  Директива .usect резервирует пространство  размером <em>size in words</em> слов в поименованной.<br>
  <em>blocking flag</em> - флаг разделения на блоки является  опциональным параметром. Если определяется ненулевое значение этого параметра, то  распределяемое пространство будет продолжать предыдущую секцию таким образом  чтобы не пересечь границу страницы, если размер не будет превышать размер  страницы. в противном случае он будет размещен по границе по началу границы  страницы.<br>
  <em>alignment flag</em> - флаг выравнивания -  опциональный параметр. Если определяется ненулевое значение этого параметра, секция  выравнивается по определяемой границе в словах .<br>
  название сечения  говорит ассемблер, который назвал сечение, чтобы резервировать пространство в. <br>
  Директивы .text,  .data и .sect сообщают ассемблеру о необходимости остановить трансляцию в  текущую секцию и начинать трансляцию в обозначенное директивами .bss и .usect пространство  сегмента, однако, при этом, не заканчивают текущую секцию и начинают новую, а  просто выходят временно из текущей секции. <br>
Директивы .bss и  .usect могут появиться в инициализированной секции, не воздействуя на ее  информационное наполнение. </p></div>
<div class="Text_Style"><p><strong>ИНИЦИАЛИЗИРОВАННЫЕ  СЕКЦИИ</strong> <br>
  Инициализированные  секции содержат исполняемый код или инициализируемые данные. Информационные  наполнения этих секций сохраняются в объектном файле и размещаются в памяти  процессора, когда программа загружена. Каждое инициализированная секция  независимо перемещаема и может ссылаться на имена, которые определены в других секциях.  Компоновщик автоматически разрешает эти ссылки между секциями. Три директивы сообщают  ассемблеру о необходимости размещать код или данные в соответствующей секции. Синтаксис  для этих директив определяется следующим образом:<br><br>
    <strong>.text </strong>[<em>value</em>]<br>
    <strong>.data </strong>[<em>value</em>]<br>
    <strong>.sect </strong>&nbsp;<em>&rdquo;section  name&rdquo;</em> [, <em>value</em>] <br><br>
    Когда ассемблер  встречает с одну из этих директив, он останавливает трансляцию в текущую секцию  (осуществляемую под воздействием текущей активной команды). Ассемблер  транслирует последовательный код в определяемую секцию, пока не встретится другая  директива .text, .data, или .sect. Значение, если оно представлено, определяет  начальное значение счетчика команд секции (SPC). Начальное значение счетчика  команд секции может быть указано только однажды. Это действие необходимо  выполнить в первый раз, когда встречается &nbsp;директива для конкретной секции. По умолчанию  секция начинается с нулевого значения счетчика SPC.<br>
    Секции и сегменты  формируются посредством итеративного процесса. Например, когда ассемблер впервые  встречает директиву .data, секция .data пуста. Операторы после этой директивы добавляются  в начало сегмента .data. Трансляция секции .data продолжается до тех пор, пока  ассемблер не встречается с новыми директивами .text или .sect. Если ассемблер  встречается с последовательными директивами .data, он добавляет операторы после  каждой этих директив .data к операторам уже существующим в секции .data. Это позволяет  создать единственную секцию .data, которая может быть добавлена в память в виде  непрерывного сегмента.<br>
    Инициализированные  подразделы могут быть созданы директивой .sect. Ассемблер обрабатывает  инициализированные секции тем же самым способом.<br></p>
</div>
<div class="Text_Style">
  <p><strong>ПОДСЕКЦИИ</strong> <br>
    Подсекции &ndash; секции  более малого размера вложенные в пределы более больших секций. Как и секции,  подсекции могут управляться компоновщиком при распределении кода и данных в  памяти. Подсекции предоставляют возможность компоновщику более оптимальным  образом распределять адресное пространство ресурсов памяти. Существует возможность  создания подсекций, используя директивы .sect или .usect. Синтаксис строки для формирования  и наименования подсекции и представлен ниже:<br><br>
  <strong>section name:subsection name</strong><br><br>
    Подсекция  идентифицируется основным названием секции, сопровождаемым двоеточием, после  этого указывается название подсекции. Подраздел может быть использован отдельно  или сгруппирован с другими секциями, использующими то же &nbsp;базовое имя.<br>
    Например, для  того, чтобы создать подсекцию, названную <em>_func</em> в пределах секции <em>.text</em>, необходимо  указать следующую строку на языке ассемблера:<br><br>
  <strong>.sect </strong>&rdquo;.text:_func&rdquo; <br><br>
    Можно распределять  подсекции <em>_func</em> отдельно или с  другими секциями сегмента .text. Можно создавать два типа подсекций:<br>
    Инициализированные  подсекции создаются, используя директиву .sect. <br>
    Неинициализированные  подсекции создаются, используя директиву .usect. </p>
</div>

<div class="Text_Style">
  <p><strong>СЕГМЕНТНЫЕ  СЧЕТЧИКИ КОМАНД</strong> <br>
    Ассемблер оперирует  и сохраняет отдельный счетчик команд для каждого сегмента или секции. Эти  счетчики команд называются сегментными счетчиками команд (Section Program Counters &ndash; SPC).<br>
    SPC представляет  собой текущий адрес используемый в пределах сегментов кода или данных.  Первоначально, по умолчанию, транслятор языка ассемблера инициализирует каждый используемый  SPC нулевым значением. Поскольку ассемблер заполняет сегмент кодом или данными,  он увеличивает соответствующий SPC, согласно размеру каждого оттранслированного  им предложения исходного кода. При возобновлении трансляции в сегменте,  ассемблер использует предыдущее сохраненное значение соответствующего сегменту SPC  и продолжает увеличивать SPC согласно протоколу трансляции исходного кода.  Ассемблер обрабатывает каждую секцию, начиная с адреса (значения) 0;  компоновщик перемещает каждое сечение согласно его конечного расположения в адресном  пространстве согласно распределяемым ресурсам памяти. </p>
</div>
<div class="Text_Style">
  <p><strong>ПРИМЕР ИСПОЛЬЗОВАНИЯ  ДИРЕКТИВ СЕГМЕНТАЦИИ</strong> <br>
    На рисунке 1.2.2  показан пример использования секций оттранслированного кода для создания COFF файла.  Использование директив сегментации позволяет реализовать механизм переключения  трансляции между создаваемыми секциями. Директивы сегментации используются для  начала инициации трансляции секции в первый раз, или продолжения трансляции в  секцию, которая уже содержит код. В последнем случае ассемблер просто добавляет  новый код к коду, который уже находится в секции в результате предыдущей  трансляции <br>
    Формат данных  приведенных на рисунке 1.2.2 представляет собой формат листинга трансляции. Показано  изменение SPC во время ассемблирования (процесс трансляции). Каждая строка  листинга содержит четыре поля:<br>
  <strong>Поле 1 (</strong><strong>Field</strong><strong>1) </strong>отображает счетчик строк  исходного текста.<br>
  <strong>Поле 2 (</strong><strong>Field</strong><strong>2) </strong>отображает счетчик команд секции.<br>
  <strong>Поле 3 (</strong><strong>Field</strong><strong>3) </strong>отображает объектный код.<br>
  <strong>Поле 4 (</strong><strong>Field</strong><strong>4) </strong>отображает операторы исходного  кода. </p>
  <p>&nbsp;</p>
</div>
<div><h3 align="center"><a name="Рис1.2.2"></a><img alt="Рис.1.2.1" src="../../images/ris010202_n.png" width="1065" height="1289"></h3>
<h3 align="center">Рисунок 1.2.2 &ndash; Использование директив сегментации для создания COFF файла</h3></div>

<div class="Text_Style">
  <p>В исходном коде,  показанном на рисунке 1.2.2, создается пять секций объектного кода (рисунок 1.2.3):</p>
  <p><strong>.text </strong>содержит десять  16-разрядных слов объектного кода.<strong></strong><br>
    <strong>.data </strong>содержит семь  слов объектного кода.<strong></strong><br>
    <strong>vectors </strong>- именованная секция,  созданная директивой .sect, содержит два слова инициализируемых данных.<strong></strong><br>
    <strong>.bss </strong>резервирует 10  слов в памяти.<strong></strong><br>
    <strong>newvars </strong>- именованная секция,  созданная директивой .usect, резервирует восемь слов в памяти.</p>
  <p>На рис 1.2.3 во  втором столбце показан объектный код, который был оттранслирован в эти секции;  первый столбец содержит номера строк исходных операторов, которые породили  соответствующий объектный код.</p>
</div>
<div><h3 align="center"><a name="Рис1.2.3"></a><img alt="Рис.1.2.3" src="../../images/ris010203_n.png" width="583" height="709"></h3>
<h3 align="center">Рисунок 1.2.3 &ndash; Объектный код порожденный в результате трансляции исходного файла (рисунок 1.2.2)</h3></div>
<div class="Text_Style">
  <p>На рисунке 1.2.4  два объектных файла file1.obj и file2.obj, которые были оттранслированы, чтобы быть  использоваными как исходные данные для работы компоновщика. Каждый из них содержит.  text, .data и .bss секции заданные по умолчанию, кроме того, каждый из этих  файлов содержат именованные секции. Исполняемый выходной модуль показывает соединение  (комбинирование) секций. Компоновщик комбинирует секцию .text file1 с секцией .text  file2, чтобы сформировать одну секцию .text, затем комбинирует секции .data, после  секции .bss, и наконец размещает именованные секции. Распределение памяти отображает  распределение секций в памяти. По умолчанию, компоновщик начинает размещение секций  по адресу 0х80 и размещает секции одну за другой как показано на рисунке 1.2.4. </p>
</div>

<div><h3 align="center"><a name="Рис1.2.4"></a><img alt="Рис.1.2.4" src="../../images/ris010204_n.png" width="696" height="592"></h3>
<h3 align="center">Рисунок 1.2.4 &ndash; Комбинирование секций объектных файлов для создания исполняемого модуля, загружаемого в память процессора</h3></div>

<div class="Text_Style"><h1>Структура предложения языка ассемблер</h1></div>

<div class="Text_Style">
  <p><strong>СИНТАКСИС  ОПЕРАТОРОВ ИСХОДНОГО КОДА </strong> <br>
    Исходный  оператор может содержать до четырех основных полей. Общий синтаксис для предложений  исходного кода следующий:</p>
  <p><strong>Мнемонический  синтаксис:</strong></p>
  <p>[<em>label</em> ] [:] <em>mnemonic</em> [<em>operand list</em>] [;<em>comment</em> ]<br>
    [метка] [:]  мнемоническое имя [список операндов] [; комментарий]</p>
  <p><strong>Алгебраический  синтаксис:</strong></p>
  <p>[<em>label</em> ] [:] <em>instruction</em> [;<em>comment</em> ] <br>
    [метка] [:]  машинная команда [; комментарий]</p>
  <p>При написании  кода необходимо придерживаться следующих рекомендаций:<br>
    - Все предложения  должны начинаться с метки, пробела, звездочки, или точки с запятой.<br>
    - Оператор,  содержащий директиву ассемблера, должен быть размещен полностью на одной  строке.<br>
    - Метки используются  опционально. <br>
    - Если метки используется,  они должны начинаться в первом столбце.<br>
    - Один или более  пробелов должен отделить каждое поле. <br>
    - Cимволы  табуляции эквивалентны пробелам.<br>
    - Комментарии используются  опционально.<br>
    - Комментарии,  которые начинаются в первом столбце, могут начаться со звездочки или точки с  запятой (* или ;), в отличие от комментариев, которые начинаются в любом другом  столбце и должны начаться только с точки с запятой (;).</p>
</div>


  <!-- (C) 2017 Shemarov Alexander, BSUIR end-->  
  
<div align="center">
	<p>
	<input type="button" class="buttonManage" value="&nbsp;Назад&nbsp;" onClick="document.location.href ='../LK01/lk_01.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Перечень тем лекций&nbsp;" onClick="document.location.href ='../../theory.htm'" />
	<input type="button" class="buttonManage" value="&nbsp;Вперед&nbsp;" onClick="document.location.href ='../LK03/lk_03.htm'" />
  </p>
  
<div class="Text_Style"><br></div>
</div>


<!--end-->
<div class="Header_Style">
<table width="100%" border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../../../Оболочка/images/background.jpg">
	<Tr>
    <td align=center colspan=2><var class="Header_Style"><A HREF="../../../index.htm">Оглавление</A> | <A HREF="../../../Программа/ППОВСРВ_программа_2017.htm" >Программа</A> | <a href="../../../Теория/theory.htm">Теория</a> | <a href="../../../Практика/practice.htm">Практика</a> |<A HREF="../../../Контроль_знаний/test.htm">Контроль знаний</A> | <A HREF="../../../Об авторах/author.htm">Об авторах</A></var></var> </td>
  <Tr>
   <td align=center><a href="https://www.bsuir.by/" title="Официальный сайт БГУИР" target="_blank">(С) БГУИР</a></td>
  </tr>
</table></div>

</BODY></HTML>